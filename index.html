<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Mapeamento - Macroscopia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
        #myCanvas {
            border: 2px solid #333;
            background-color: #f7f7f7;
            cursor: default;
        }
        button {
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
            margin-bottom: 15px;
            background-color: #eee;
            border: 1px solid #ccc;
            color: #333;
        }
        .form-buttons button { background-color: #ddd; border-color: #bbb; }
        .action-buttons button { background-color: #ccc; border-color: #999; }
        .label-buttons button { background-color: #f7f7f7; border-color: #ccc; }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            width: 300px;
        }
        .modal-content label { display: block; margin-bottom: 8px; font-weight: bold; }
        .modal-content input[type="number"] {
            width: 90%;
            padding: 8px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .modal-actions { text-align: right; margin-top: 10px; }
    </style>
</head>
<body>

    <h2>Mapeamento Patol√≥gico</h2>

    <h3>1. Selecionar Pe√ßa Base</h3>
    <div class="form-buttons">
        <button onclick="drawForm('breast')">Mama</button>
        <button onclick="drawForm('bone_drawn')">Osso</button>
    </div>

    <h3>2. Ferramentas de Les√£o e Cortes</h3>
    <div class="action-buttons">
        <button onclick="showLesionModal(true)">üî™ Adicionar Les√£o c/ Cortes</button>
        <button onclick="showLesionModal(false)">‚ö´ Adicionar Les√£o (Sem Cortes)</button>
        <button onclick="showSectionModal()">üî¢ Adicionar sec√ß√µes</button>
        <button onclick="downloadImage()">‚¨áÔ∏è Baixar Imagem (PNG)</button>
    </div>

    <h3>3. Margens</h3>
    <div class="label-buttons">
        <button onclick="addLabel('Pele')">Pele</button>
        <button onclick="addLabel('Inferior')">Inferior</button>
        <button onclick="addLabel('Superior')">Superior</button>
        <button onclick="addLabel('Lateral')">Lateral</button>
        <button onclick="addLabel('Medial')">Medial</button>
        <button onclick="addLabel('Anterior')">Anterior</button>
        <button onclick="addLabel('Posterior')">Posterior</button>
    </div>

    <p style="font-size: 0.9em; color: #666;">Use <strong>Delete/Backspace</strong> para remover objetos selecionados.</p>
    <br>

    <canvas id="myCanvas" width="1000" height="700"></canvas>

    <div id="lesionModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Configurar Les√£o</h3>

            <label for="lesionNumber">N√∫mero da fatia escolhida:</label>
            <input type="number" id="lesionNumber" value="1" min="1">

            <hr>
            <label for="cutsTransversal">Cortes Transversais:</label>
            <input type="number" id="cutsTransversal" value="1" min="1">

            <label for="cutsLongitudinal">Cortes Longitudinais:</label>
            <input type="number" id="cutsLongitudinal" value="1" min="1">

            <hr>
            <label for="lesionWidth">Largura (cm):</label>
            <input type="number" id="lesionWidth" value="3.0" min="0.1" step="0.1">

            <label for="lesionHeight">Comprimento (cm):</label>
            <input type="number" id="lesionHeight" value="3.0" min="0.1" step="0.1">

            <div class="modal-actions">
                <button onclick="hideLesionModal()">Cancelar</button>
                <button onclick="processLesionData()">Adicionar</button>
            </div>
        </div>
    </div>

    <div id="sectionModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Fatiar Pe√ßa Anat√¥mica</h3>

            <label for="pieceSections">N√∫mero de Se√ß√µes Verticais:</label>
            <input type="number" id="pieceSections" value="3" min="2">

            <div class="modal-actions">
                <button onclick="hideSectionModal()">Cancelar</button>
                <button onclick="processSectionData()">Fatiar e Numerar</button>
            </div>
        </div>
    </div>

    <script>
        let canvas;
        let history = [];
        let historyPointer = -1;
        let isRedoing = false;
        let isLesionWithCuts = false;

        const LESION_RADIUS = 50;
        const LESION_DIAMETER = LESION_RADIUS * 2;
        const UNIT = 'cm';
        // Ajuste: reduzir deslocamento para mover o osso mais para a DIREITA
        const LEFT_OFFSET = 70; // <<-- alterado de 200 para 120

        let boneImageObject = null;

        document.addEventListener('DOMContentLoaded', () => {
            canvas = new fabric.Canvas('myCanvas', {
                preserveObjectStacking: true
            });
            window.CANVAS_CENTER_X = canvas.width / 2;
            window.CANVAS_CENTER_Y = canvas.height / 2;

            drawForm('breast');

            canvas.on('object:modified', saveState);
            canvas.on('object:removed', saveState);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    undo();
                }
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const activeObject = canvas.getActiveObject();
                    if (activeObject) {
                        canvas.remove(activeObject);
                        saveState();
                        e.preventDefault();
                    }
                }
            });
        });

        function saveState() {
            if (isRedoing) return;
            history = history.slice(0, historyPointer + 1);
            const json = canvas.toJSON(['type', 'subType', 'widthValue', 'heightValue', 'lesionNumber']);
            history.push(json);
            historyPointer = history.length - 1;
            if (history.length > 50) {
                history.shift();
                historyPointer--;
            }
        }

        function undo() {
            if (historyPointer > 0) {
                isRedoing = true;
                historyPointer--;
                canvas.loadFromJSON(history[historyPointer], () => {
                    boneImageObject = canvas.getObjects().find(o => o.type === 'boneImage') || null;
                    canvas.renderAll();
                    isRedoing = false;
                });
            }
        }

        function clearBaseShapes() {
            const toRemove = canvas.getObjects().filter(o => o.type === 'baseShape' || o.type === 'boneImage');
            toRemove.forEach(o => canvas.remove(o));
        }

        function drawForm(shapeType) {
            clearBaseShapes();

            if (shapeType === 'breast') {
                if (boneImageObject) {
                    canvas.remove(boneImageObject);
                    boneImageObject = null;
                }

                const breastShape = new fabric.Ellipse({
                    rx: 300, ry: 180, fill: 'white',
                    stroke: 'black', strokeWidth: 4,
                    originX: 'center', originY: 'center',
                    left: CANVAS_CENTER_X - LEFT_OFFSET,
                    top: CANVAS_CENTER_Y,
                    selectable: true, evented: true, hasControls: true, lockRotation: true,
                    type: 'baseShape', subType: 'breast'
                });
                canvas.add(breastShape);
                breastShape.sendToBack();
                canvas.renderAll();
                saveState();
            } else if (shapeType === 'bone_drawn') {
                if (boneImageObject) {
                    // reposiciona caso j√° exista
                    boneImageObject.left = CANVAS_CENTER_X - LEFT_OFFSET;
                    boneImageObject.top = CANVAS_CENTER_Y;
                    boneImageObject.setCoords();
                    boneImageObject.sendToBack();
                    canvas.renderAll();
                    bringCutsToFront();
                    saveState();
                    return;
                }

                fabric.Image.fromURL('osso.jpg', function(img) {
                    if (!img) {
                        alert('N√£o foi poss√≠vel carregar "osso.jpg". Verifique o caminho/arquivo.');
                        return;
                    }

                    // ESCALA: ajustar para n√£o for√ßar overflow (removi o *1.05)
                    const scaleX = canvas.width / img.width;
                    const scaleY = canvas.height / img.height;
                    const scale = Math.max(scaleX, scaleY); // sem multiplicador extra

                    img.set({
                        originX: 'center',
                        originY: 'center',
                        left: CANVAS_CENTER_X - LEFT_OFFSET, // usa LEFT_OFFSET reduzido (120)
                        top: CANVAS_CENTER_Y,
                        selectable: false,
                        evented: false,
                        hasControls: false,
                        hoverCursor: 'default',
                        type: 'boneImage',
                        subType: 'bone_photo',
                        angle: 180,
                        scaleX: scale,
                        scaleY: scale
                    });

                    boneImageObject = img;
                    canvas.add(boneImageObject);
                    boneImageObject.sendToBack();

                    bringCutsToFront();

                    canvas.requestRenderAll();
                    saveState();
                }, { crossOrigin: 'anonymous' });
            }
        }

        function bringCutsToFront() {
            const cuts = canvas.getObjects().filter(o => o.type === 'pieceCutLine' || o.type === 'pieceSectionNumber');
            cuts.forEach(obj => canvas.bringToFront(obj));

            const lesionCuts = canvas.getObjects().filter(o => o.type === 'lesionGroup' || o.type === 'cutLine' || o.type === 'sectionNumber');
            lesionCuts.forEach(obj => canvas.bringToFront(obj));

            canvas.requestRenderAll();
        }

        function showLesionModal(withCuts) {
            isLesionWithCuts = withCuts;
            if (withCuts) {
                document.getElementById('lesionModal').style.display = 'flex';
            } else {
                drawLesionWithCuts(CANVAS_CENTER_X - LEFT_OFFSET, CANVAS_CENTER_Y, LESION_DIAMETER, LESION_DIAMETER, 1, 1, 3.0, 3.0, 0);
            }
        }

        function hideLesionModal() {
            document.getElementById('lesionModal').style.display = 'none';
        }

        function processLesionData() {
            const lesionNumber = parseInt(document.getElementById('lesionNumber').value) || 1;
            const cutsTransversal = parseInt(document.getElementById('cutsTransversal').value) || 1;
            const cutsLongitudinal = parseInt(document.getElementById('cutsLongitudinal').value) || 1;
            const widthValue = parseFloat(document.getElementById('lesionWidth').value) || 3.0;
            const heightValue = parseFloat(document.getElementById('lesionHeight').value) || 3.0;

            drawLesionWithCuts(CANVAS_CENTER_X - LEFT_OFFSET, CANVAS_CENTER_Y, LESION_DIAMETER, LESION_DIAMETER, cutsTransversal, cutsLongitudinal, widthValue, heightValue, lesionNumber);
            hideLesionModal();
        }

        function drawLesionWithCuts(x, y, width, height, sectionsTransversal, sectionsLongitudinal, widthValue, heightValue, lesionNumber) {
            if (!canvas) return;

            const radius = width / 2;

            const lesionCircle = new fabric.Circle({
                radius: radius, left: 0, top: 0, fill: 'black', stroke: 'transparent',
                originX: 'center', originY: 'center', type: 'lesionCircle'
            });

            let cutLines = [];
            let sectionNumbers = [];
            let ruler = [];

            if (isLesionWithCuts) {
                ruler = createRuler(widthValue, heightValue, width, height);

                const totalWidth = width;
                const totalHeight = height;
                const spacingX = totalWidth / sectionsTransversal;
                const spacingY = totalHeight / sectionsLongitudinal;

                for (let i = 1; i < sectionsLongitudinal; i++) {
                    const lineY = -totalHeight / 2 + i * spacingY;
                    cutLines.push(new fabric.Line([-totalWidth / 2, lineY, totalWidth / 2, lineY], {
                        stroke: 'white', strokeWidth: 1.5, selectable: false, evented: false, type: 'cutLine'
                    }));
                }
                for (let j = 1; j < sectionsTransversal; j++) {
                    const lineX = -totalWidth / 2 + j * spacingX;
                    cutLines.push(new fabric.Line([lineX, -totalHeight / 2, lineX, totalHeight / 2], {
                        stroke: 'white', strokeWidth: 1.5, selectable: false, evented: false, type: 'cutLine'
                    }));
                }

                let letterCounter = 0;
                let sections = [];

                for (let i = 0; i < sectionsLongitudinal; i++) {
                    for (let j = 0; j < sectionsTransversal; j++) {
                        const xStart = -totalWidth / 2 + j * spacingX;
                        const yStart = -totalHeight / 2 + i * spacingY;
                        sections.push({ midX: xStart + spacingX / 2, midY: yStart + spacingY / 2, row: i });
                    }
                }

                let orderedSections = [];
                let groupsByRow = sections.reduce((acc, curr) => {
                    acc[curr.row] = acc[curr.row] || [];
                    acc[curr.row].push(curr);
                    return acc;
                }, {});

                let rows = Object.keys(groupsByRow).map(key => groupsByRow[key]);

                const maxSectionsInRow = sectionsTransversal;
                for (let j = 0; j < maxSectionsInRow; j++) {
                    for (let i = 0; i < rows.length; i++) {
                        if (rows[i][j]) {
                            orderedSections.push(rows[i][j]);
                        }
                    }
                }

                orderedSections.forEach(section => {
                    const text = `${lesionNumber}${String.fromCharCode(65 + letterCounter)}`;
                    sectionNumbers.push(new fabric.Text(text, {
                        fontSize: 12, fill: 'white', left: section.midX, top: section.midY, originX: 'center', originY: 'center', type: 'sectionNumber',
                    }));
                    letterCounter++;
                });
            }

            const lesionGroup = new fabric.Group([lesionCircle, ...cutLines, ...sectionNumbers, ...ruler], {
                left: x,
                top: y,
                originX: 'center',
                originY: 'center',
                selectable: true,
                hasControls: true,
                lockRotation: false,
                type: 'lesionGroup',
                widthValue: widthValue,
                heightValue: heightValue,
                lesionNumber: lesionNumber
            });

            canvas.add(lesionGroup);
            lesionGroup.bringToFront();
            canvas.renderAll();

            saveState();
        }

        function showSectionModal() {
            document.getElementById('sectionModal').style.display = 'flex';
        }

        function hideSectionModal() {
            document.getElementById('sectionModal').style.display = 'none';
        }

        function processSectionData() {
            const numSections = parseInt(document.getElementById('pieceSections').value) || 3;
            drawPieceSections(numSections);
            hideSectionModal();
        }

        function drawPieceSections(numSections) {
            if (!canvas) return;

            const baseShape = canvas.getObjects().find(obj => obj.type === 'baseShape' || obj.type === 'boneImage');
            if (!baseShape) {
                alert("Por favor, selecione uma pe√ßa anat√¥mica (Mama ou Osso) primeiro.");
                return;
            }

            canvas.getObjects().filter(obj => obj.type === 'pieceCutLine' || obj.type === 'pieceSectionNumber').forEach(obj => canvas.remove(obj));

            let shapeLeft, shapeTop, shapeWidth, shapeHeight;
            if (baseShape.type === 'boneImage') {
                const bb = baseShape.getBoundingRect(true, true);
                shapeLeft = bb.left;
                shapeTop = bb.top;
                shapeWidth = bb.width;
                shapeHeight = bb.height;
            } else {
                shapeLeft = baseShape.left - baseShape.getScaledWidth() / 2;
                shapeTop = baseShape.top - baseShape.getScaledHeight() / 2;
                shapeWidth = baseShape.getScaledWidth();
                shapeHeight = baseShape.getScaledHeight();
            }

            const spacing = shapeWidth / numSections;

            for (let i = 1; i < numSections; i++) {
                const lineX = shapeLeft + (i * spacing);

                const line = new fabric.Line([lineX, shapeTop, lineX, shapeTop + shapeHeight], {
                    stroke: 'red',
                    strokeWidth: 2,
                    selectable: false,
                    evented: false,
                    type: 'pieceCutLine'
                });
                canvas.add(line);
                canvas.bringToFront(line);
            }

            for (let i = 0; i < numSections; i++) {
                const textX = shapeLeft + i * spacing + spacing / 2;
                const textY = shapeTop + shapeHeight + 20;

                const number = new fabric.Text((i + 1).toString(), {
                    fontSize: 20, fill: 'red', left: textX, top: textY, originX: 'center', originY: 'center', type: 'pieceSectionNumber'
                });
                canvas.add(number);
                canvas.bringToFront(number);
            }

            bringCutsToFront();

            canvas.renderAll();
            saveState();
        }

        function addLabel(text) {
            const label = new fabric.Text(text, {
                fontSize: 24,
                fill: 'black',
                left: CANVAS_CENTER_X - LEFT_OFFSET + 100,
                top: CANVAS_CENTER_Y - 150,
                originX: 'center',
                originY: 'center',
                selectable: true,
                hasControls: true,
                type: 'label'
            });
            canvas.add(label);
            canvas.renderAll();
            saveState();
        }

        function createRuler(widthValue, heightValue, containerWidth, containerHeight) {
            const rulerElements = [];
            const offset = 10;
            const tickSize = 5;
            const halfWidth = containerWidth / 2;
            const halfHeight = containerHeight / 2;
            const fillColor = 'black';

            const textWidth = `${widthValue.toFixed(1)} ${UNIT}`;
            const widthPosition = halfHeight + offset;

            rulerElements.push(new fabric.Line([-halfWidth, widthPosition, halfWidth, widthPosition], {
                stroke: fillColor, strokeWidth: 1, originX: 'center', originY: 'center', type: 'ruler'
            }));
            rulerElements.push(new fabric.Line([-halfWidth, widthPosition - tickSize, -halfWidth, widthPosition + tickSize], { stroke: fillColor, strokeWidth: 1, originX: 'center', originY: 'center', type: 'ruler' }));
            rulerElements.push(new fabric.Line([halfWidth, widthPosition - tickSize, halfWidth, widthPosition + tickSize], { stroke: fillColor, strokeWidth: 1, originX: 'center', originY: 'center', type: 'ruler' }));

            rulerElements.push(new fabric.Text(textWidth, {
                fontSize: 14, fill: fillColor, left: 0, top: widthPosition + tickSize + 2, originX: 'center', originY: 'top', type: 'ruler'
            }));

            const textHeight = `${heightValue.toFixed(1)} ${UNIT}`;
            const heightPosition = halfWidth + offset;

            rulerElements.push(new fabric.Line([heightPosition, -halfHeight, heightPosition, halfHeight], {
                stroke: fillColor, strokeWidth: 1, originX: 'center', originY: 'center', type: 'ruler'
            }));
            rulerElements.push(new fabric.Line([heightPosition - tickSize, -halfHeight, heightPosition + tickSize, -halfHeight], { stroke: fillColor, strokeWidth: 1, originX: 'center', originY: 'center', type: 'ruler' }));
            rulerElements.push(new fabric.Line([heightPosition - tickSize, halfHeight, heightPosition + tickSize, halfHeight], { stroke: fillColor, strokeWidth: 1, originX: 'center', originY: 'center', type: 'ruler' }));

            rulerElements.push(new fabric.Text(textHeight, {
                fontSize: 14, fill: fillColor, left: heightPosition + tickSize + 2, top: 0, originX: 'left', originY: 'center', type: 'ruler'
            }));

            return rulerElements;
        }

        function downloadImage() {
            if (!canvas) return;

            const dataURL = canvas.toDataURL({
                format: 'png',
                quality: 1,
                enableRetinaScaling: false
            });

            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'Mapeamento_Patologico.png';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
    </script>
</body>
</html>
